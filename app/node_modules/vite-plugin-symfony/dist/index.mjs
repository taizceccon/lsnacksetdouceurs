// src/index.ts
import { resolve as resolve2, join as join3, relative, dirname } from "node:path";
import { existsSync, mkdirSync, readFileSync } from "node:fs";
import sirv from "sirv";
import colors2 from "picocolors";

// src/entryPointsHelper.ts
import { cwd } from "process";
import { resolve, extname } from "path";

// src/utils.ts
import os from "node:os";
import path from "node:path";
import colors from "picocolors";
import { writeFileSync, rmSync, readdirSync } from "fs";
import { join } from "path";
var isWindows = os.platform() === "win32";
function slash(p) {
  return p.replace(/\\/g, "/");
}
function normalizePath(id) {
  return path.posix.normalize(isWindows ? slash(id) : id);
}
function getLegacyName(name) {
  const ext = path.extname(name);
  const endPos = ext.length !== 0 ? -ext.length : void 0;
  name = name.slice(0, endPos) + `-legacy` + ext;
  return name;
}
function isIpv6(address) {
  return address.family === "IPv6" || // In node >=18.0 <18.4 this was an integer value. This was changed in a minor version.
  // See: https://github.com/laravel/vite-plugin/issues/103
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore-next-line
  address.family === 6;
}
function logConfig(config, server, depth) {
  Object.entries(config).map(([key, value]) => {
    const prefix = " ".repeat(depth);
    const keySpaces = prefix + colors.dim(key) + " ".repeat(30 - key.length - prefix.length);
    if (typeof value === "undefined" || typeof value === "boolean" || typeof value === "number" || typeof value === "bigint") {
      server.config.logger.info(`${keySpaces}: ${value ? colors.green(value.toString()) : value}`);
    } else if (typeof value === "string") {
      server.config.logger.info(`${keySpaces}: ${value ? colors.green('"' + value.toString() + '"') : value}`);
    } else if (typeof value === "symbol") {
      server.config.logger.info(`${keySpaces}: symbol`);
    } else if (typeof value === "function") {
      server.config.logger.info(`${keySpaces}: function`);
    } else if (value === null) {
      server.config.logger.info(`${keySpaces}: null`);
    } else if (typeof value === "object") {
      server.config.logger.info(`${key}:`);
      logConfig(value, server, depth + 2);
    } else {
      server.config.logger.info(`${keySpaces}: unknown`);
    }
  });
}
var writeJson = (filePath, jsonData) => {
  try {
    writeFileSync(filePath, JSON.stringify(jsonData, null, 2));
  } catch (err) {
    throw new Error(`Error writing entrypoints.json ${err.message}`);
  }
};
var emptyDir = (dir) => {
  const files = readdirSync(dir);
  for (const file of files) {
    rmSync(join(dir, file), { recursive: true });
  }
};

// src/entryPointsHelper.ts
import path2 from "node:path";
var entryPath2exportPath = {};
var getDevEntryPoints = (config, viteDevServerUrl) => {
  const entryPoints = {};
  for (const [entryName, { entryPath, entryType }] of Object.entries(prepareRollupInputs(config))) {
    entryPoints[entryName] = {
      [entryType]: [`${viteDevServerUrl}${config.base}${entryPath}`]
    };
  }
  return entryPoints;
};
var addBuildEntryPoints = (options, config, bundle, entryPoints) => {
  for (const chunkName in bundle) {
    entryPath2exportPath[getEntryPath(bundle[chunkName], options, config)] = chunkName;
  }
  const entryFiles = prepareRollupInputs(config);
  for (const [entryName, entry] of Object.entries(entryFiles)) {
    let exportPath = entryPath2exportPath[entry.entryPath];
    let fileInfos = bundle[exportPath];
    let isLegacy = false;
    if (!fileInfos) {
      const legacyEntryPath = getLegacyName(entry.entryPath);
      exportPath = entryPath2exportPath[legacyEntryPath];
      fileInfos = bundle[exportPath];
      if (!fileInfos) {
        continue;
      }
      isLegacy = true;
    }
    const defaultEntryName = isLegacy ? `${entryName}-legacy` : entryName;
    const legacyEntryName = typeof entryPoints[`${defaultEntryName}-legacy`] !== "undefined" ? `${defaultEntryName}-legacy` : false;
    entryPoints[defaultEntryName] = resolveEntrypoint(fileInfos, bundle, config, legacyEntryName, true);
  }
  if (entryPath2exportPath["vite/legacy-polyfills-legacy"]) {
    const fileInfos = bundle[entryPath2exportPath["vite/legacy-polyfills-legacy"]];
    if (fileInfos) {
      entryPoints["polyfills-legacy"] = resolveEntrypoint(fileInfos, bundle, config, false, true);
    }
  }
  return entryPoints;
};
var getEntryPath = (chunk, options, config) => {
  if (chunk.type === "asset") {
    return chunk.name;
  } else if (chunk.type === "chunk") {
    if (chunk.facadeModuleId) {
      let name = normalizePath(path2.relative(config.root, chunk.facadeModuleId));
      if (options.format === "system" && !chunk.name.includes("-legacy")) {
        name = getLegacyName(name);
      }
      return name.replace(/\0/g, "");
    } else {
      return chunk.fileName;
    }
  }
};
var resolveEntrypoint = (fileInfos, bundle, config, legacyEntryName, isCSSOrJsEntry) => {
  const js = [];
  const css = [];
  const preload = [];
  if (fileInfos.imports) {
    for (const importEntryName of fileInfos.imports) {
      const importFileInfos = bundle[importEntryName];
      if (!importFileInfos) {
        throw new Error(`Unable to find ${importEntryName}`);
      }
      const { css: importCss, preload: importPreload } = resolveEntrypoint(
        importFileInfos,
        bundle,
        config,
        false,
        false
      );
      for (const dependency of importCss) {
        if (css.indexOf(dependency) === -1) {
          css.push(dependency);
        }
      }
      for (const dependency of importPreload) {
        if (preload.indexOf(dependency) === -1) {
          preload.push(dependency);
        }
      }
    }
  }
  const filePath = `${config.base}${fileInfos.fileName}`;
  if (isCSSOrJsEntry) {
    if (fileInfos.isEntry) {
      js.push(filePath);
    } else {
      css.push(filePath);
    }
  } else if (preload.indexOf(filePath) === -1) {
    preload.push(filePath);
  }
  if (fileInfos.viteMetadata?.importedCss.size) {
    fileInfos.viteMetadata.importedCss.forEach((cssFilePath) => {
      css.push(`${config.base}${cssFilePath}`);
    });
  }
  return { js, css, preload, legacy: legacyEntryName };
};
var prepareRollupInputs = (config) => {
  const inputParsed = {};
  for (const [entryName, entryPath] of Object.entries(config.build.rollupOptions.input)) {
    const entryAbsolutePath = normalizePath(resolve(cwd(), entryPath));
    if (entryAbsolutePath.indexOf(config.root) !== 0) {
      console.error("Entry points must be inside Vite root directory");
      process.exit(1);
    }
    const extension = extname(entryPath);
    const entryType = [".css", ".scss", ".sass", ".less", ".styl", ".stylus", ".postcss"].indexOf(extension) !== -1 ? "css" : "js";
    const entryRelativePath = entryAbsolutePath.substring(config.root.length + 1);
    inputParsed[entryName] = {
      entryType,
      entryPath: entryRelativePath
    };
  }
  return inputParsed;
};

// src/pluginOptions.ts
import { join as join2 } from "node:path";
function resolvePluginOptions(userConfig = {}) {
  if (typeof userConfig.publicDirectory === "string") {
    userConfig.publicDirectory = userConfig.publicDirectory.trim().replace(/^\/+/, "");
    if (userConfig.publicDirectory === "") {
      throw new Error("vite-plugin-symfony: publicDirectory must be a subdirectory. E.g. 'public'.");
    }
  }
  if (typeof userConfig.buildDirectory === "string") {
    userConfig.buildDirectory = userConfig.buildDirectory.trim().replace(/^\/+/, "").replace(/\/+$/, "");
    if (userConfig.buildDirectory === "") {
      throw new Error("vite-plugin-symfony: buildDirectory must be a subdirectory. E.g. 'build'.");
    }
  }
  if (userConfig.servePublic !== false) {
    userConfig.servePublic = true;
  }
  return {
    servePublic: userConfig.servePublic,
    publicDirectory: userConfig.publicDirectory ?? "public",
    buildDirectory: userConfig.buildDirectory ?? "build",
    refresh: userConfig.refresh ?? false,
    viteDevServerHostname: userConfig.viteDevServerHostname ?? null,
    verbose: userConfig.verbose === true
  };
}
function resolveBase(config) {
  return "/" + config.buildDirectory + "/";
}
function resolveOutDir(config) {
  return join2(config.publicDirectory, config.buildDirectory);
}

// src/index.ts
import { fileURLToPath } from "node:url";
var FS_PREFIX = `/@fs/`;
var VALID_ID_PREFIX = `/@id/`;
var CLIENT_PUBLIC_PATH = `/@vite/client`;
var ENV_PUBLIC_PATH = `/@vite/env`;
var pluginDir = dirname(dirname(fileURLToPath(import.meta.url)));
var importQueryRE = /(\?|&)import=?(?:&|$)/;
var internalPrefixes = [FS_PREFIX, VALID_ID_PREFIX, CLIENT_PUBLIC_PATH, ENV_PUBLIC_PATH];
var InternalPrefixRE = new RegExp(`^(?:${internalPrefixes.join("|")})`);
var isImportRequest = (url) => importQueryRE.test(url);
var isInternalRequest = (url) => InternalPrefixRE.test(url);
var refreshPaths = ["templates/**/*.twig"];
function resolveDevServerUrl(address, config, pluginOptions) {
  if (config.server?.origin) {
    return config.server.origin;
  }
  const configHmrProtocol = typeof config.server.hmr === "object" ? config.server.hmr.protocol : null;
  const clientProtocol = configHmrProtocol ? configHmrProtocol === "wss" ? "https" : "http" : null;
  const serverProtocol = config.server.https ? "https" : "http";
  const protocol = clientProtocol ?? serverProtocol;
  const configHmrHost = typeof config.server.hmr === "object" ? config.server.hmr.host : null;
  const configHost = typeof config.server.host === "string" ? config.server.host : null;
  const serverAddress = isIpv6(address) ? `[${address.address}]` : address.address;
  const host = configHmrHost ?? pluginOptions.viteDevServerHostname ?? configHost ?? serverAddress;
  const configHmrClientPort = typeof config.server.hmr === "object" ? config.server.hmr.clientPort : null;
  const port = configHmrClientPort ?? address.port;
  return `${protocol}://${host}:${port}`;
}
function symfony(userOptions = {}) {
  const pluginOptions = resolvePluginOptions(userOptions);
  let viteConfig;
  let viteDevServerUrl;
  const entryPointsFilename = "entrypoints.json";
  const entryPoints = {};
  let outputCount = 0;
  return {
    name: "symfony",
    enforce: "post",
    config(userConfig) {
      if (userConfig.build.rollupOptions.input instanceof Array) {
        console.error("rollupOptions.input must be an Objet like {app: './assets/app.js'}");
        process.exit(1);
      }
      const extraConfig = {
        base: userConfig.base ?? resolveBase(pluginOptions),
        publicDir: false,
        build: {
          manifest: true,
          outDir: userConfig.build?.outDir ?? resolveOutDir(pluginOptions)
        },
        optimizeDeps: {
          //Set to true to force dependency pre-bundling.
          force: true
        }
      };
      return extraConfig;
    },
    configResolved(config) {
      viteConfig = config;
    },
    configureServer(devServer) {
      const { watcher, ws } = devServer;
      devServer.httpServer?.once("listening", () => {
        if (viteConfig.env.DEV) {
          const buildDir = resolve2(viteConfig.root, viteConfig.build.outDir);
          if (!existsSync(buildDir)) {
            mkdirSync(buildDir, { recursive: true });
          }
          existsSync(buildDir) && emptyDir(buildDir);
          const address = devServer.httpServer?.address();
          const isAddressInfo = (x) => typeof x === "object";
          if (!isAddressInfo(address)) {
            console.error("address is not an object open an issue with your address value to fix the problem", address);
            process.exit(1);
          }
          viteDevServerUrl = resolveDevServerUrl(address, devServer.config, pluginOptions);
          const entryPoints2 = getDevEntryPoints(viteConfig, viteDevServerUrl);
          const entryPointsPath = resolve2(viteConfig.root, viteConfig.build.outDir, entryPointsFilename);
          writeJson(entryPointsPath, {
            isProd: false,
            viteServer: {
              origin: viteDevServerUrl,
              base: viteConfig.base
            },
            entryPoints: entryPoints2,
            legacy: false
          });
        }
        if (pluginOptions.verbose) {
          setTimeout(() => {
            devServer.config.logger.info(`
${colors2.green("\u279C")}  Vite Config`);
            logConfig(viteConfig, devServer, 0);
            devServer.config.logger.info(`
${colors2.green("\u279C")}  End of config 
`);
          }, 100);
        }
      });
      if (pluginOptions.refresh !== false) {
        const paths = pluginOptions.refresh === true ? refreshPaths : pluginOptions.refresh;
        for (const path3 of paths) {
          watcher.add(path3);
        }
        watcher.on("change", function(path3) {
          if (path3.endsWith(".twig")) {
            ws.send({
              type: "full-reload"
            });
          }
        });
      }
      if (pluginOptions.servePublic) {
        const serve = sirv(pluginOptions.publicDirectory, {
          dev: true,
          etag: true,
          extensions: [],
          setHeaders(res, pathname) {
            if (/\.[tj]sx?$/.test(pathname)) {
              res.setHeader("Content-Type", "application/javascript");
            }
            res.setHeader("Access-Control-Allow-Origin", "*");
          }
        });
        devServer.middlewares.use(function viteServePublicMiddleware(req, res, next) {
          if (req.url === "/" || req.url === "/build/") {
            res.statusCode = 404;
            res.end(readFileSync(join3(pluginDir, "static/dev-server-404.html")));
            return;
          }
          if (isImportRequest(req.url) || isInternalRequest(req.url)) {
            return next();
          }
          serve(req, res, next);
        });
      }
    },
    async renderChunk(code, chunk, opts) {
      if (!chunk.isEntry) {
        return;
      }
      const fileExt = chunk.facadeModuleId.split(".").pop();
      if (["css", "scss", "sass", "less", "styl", "stylus", "postcss"].indexOf(fileExt) === -1) {
        return;
      }
      const cssAssetName = chunk.facadeModuleId ? normalizePath(relative(viteConfig.root, chunk.facadeModuleId)) : chunk.name;
      chunk.viteMetadata.importedCss.forEach((cssBuildFilename) => {
        entryPath2exportPath[cssAssetName] = cssBuildFilename;
      });
    },
    generateBundle(options, bundle) {
      addBuildEntryPoints(options, viteConfig, bundle, entryPoints);
      outputCount++;
      const output = viteConfig.build.rollupOptions?.output;
      const outputLength = Array.isArray(output) ? output.length : 1;
      if (outputCount >= outputLength) {
        this.emitFile({
          fileName: entryPointsFilename,
          type: "asset",
          source: JSON.stringify(
            {
              isProd: true,
              viteServer: false,
              entryPoints,
              legacy: typeof entryPoints["polyfills-legacy"] !== "undefined"
            },
            null,
            2
          )
        });
      }
    }
  };
}
export {
  symfony as default
};
